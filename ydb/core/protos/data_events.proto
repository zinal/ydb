import "ydb/library/actors/protos/actors.proto";
import "ydb/core/protos/base.proto";
import "ydb/core/protos/query_stats.proto";
import "ydb/public/api/protos/ydb_issue_message.proto";

package NKikimrDataEvents;
option java_package = "ru.yandex.kikimr.proto";

message TLock {
    optional fixed64 LockId = 1;
    optional fixed64 DataShard = 2;
    optional uint32 Generation = 3;
    optional uint64 Counter = 4;
    optional fixed64 SchemeShard = 5;
    optional uint64 PathId = 6;
    optional bool HasWrites = 7;
}

message TKqpLocks {
    repeated TLock Locks = 1;
    repeated uint64 SendingShards = 2;   // empty on Rollback
    repeated uint64 ReceivingShards = 3; // empty on Rollback

    enum ELocksOp {
        Unspecified = 0;
        reserved 1; // Validate op is deprecated
        Commit = 2; // Validate locks, commit buffered changes and erase locks
        Rollback = 3; // Rollback buffered changes and erase locks
    }
    optional ELocksOp Op = 4;

    // An optional arbiter for readsets. When specified, all sending shards
    // send the commit decision to a single arbiter shard, and all receiving
    // shards wait for the commit decision from a single arbiter shard. The
    // shard marked as the arbiter is responsible in aggregating all commit
    // decisions from sending shards and sending the final commit decision to
    // receiving shards.
    // This may only be used with generic readsets without any other data and
    // currently limited to volatile transactions.
    optional uint64 ArbiterShard = 5;

    optional uint64 ArbiterColumnShard = 6;
}

message TTableId {
    optional uint64 OwnerId = 1;
    optional uint64 TableId = 2;
    optional uint64 SchemaVersion = 3;
}

message TTabletInfo {
    optional fixed64 TabletId = 1;
    optional uint32 Generation = 2;
    optional uint64 Step = 3;
    optional NActorsProto.TActorId ActorId = 4;
    optional bool IsFollower = 5;
}

message TMvccSnapshot {
    optional uint64 Step = 10;
    optional uint64 TxId = 11;
    // When true (the default) reads from the specified snapshot are expected
    // to be repeatable, i.e. future reads with the same snapshot version must
    // observe the same data. For non-repeatable reads (or writes) the above
    // version is the minimum MVCC version for the operation, shards may use
    // a higher MVCC version when appropriate.
    optional bool RepeatableRead = 12 [default = true];
}

enum ELockMode {
    OPTIMISTIC = 0;
    OPTIMISTIC_SNAPSHOT_ISOLATION = 1;
    PESSIMISTIC_EXCLUSIVE = 2;
}

enum EDataFormat {
    FORMAT_UNSPECIFIED = 0;
    FORMAT_CELLVEC = 1;
    FORMAT_ARROW = 2;
}

message TEvWrite {
    enum ETxMode {
        MODE_UNSPECIFIED = 0;
        MODE_PREPARE = 1;
        MODE_VOLATILE_PREPARE  = 2;
        MODE_IMMEDIATE  = 3;
    }

    message TOperation {
        enum EOperationType {
            OPERATION_UNSPECIFIED = 0;
            OPERATION_INSERT = 1;
            OPERATION_DELETE = 2;
            OPERATION_UPDATE = 3;
            OPERATION_UPSERT = 4;
            OPERATION_REPLACE = 5;
            OPERATION_INCREMENT = 6;
            OPERATION_UPSERT_INCREMENT = 7;
        }

        optional EOperationType Type = 1;
        optional TTableId TableId = 2;
        repeated uint32 ColumnIds = 3 [packed = true];
        optional uint64 PayloadIndex = 4;
        optional EDataFormat PayloadFormat = 5;
        optional string PayloadSchema = 6;
        optional uint32 DefaultFilledColumnCount = 7;
        optional bool IsBulk = 8;
        optional uint64 QuerySpanId = 9;
    }

    // Transaction operations
    repeated TOperation Operations = 1;

    // Transactions params
    optional uint64 TxId = 2;
    optional ETxMode TxMode = 3;
    optional uint64 LockTxId = 4;
    optional uint32 LockNodeId = 5;
    optional TKqpLocks Locks = 6;

    // Other params
    optional uint64 OverloadSubscribe = 7;

    // Writes are performed "over" the specified snapshot when specified
    // This mostly affects the minimum MVCC version of the resulting write
    optional TMvccSnapshot MvccSnapshot = 8;
    optional uint32 GranuleShardingVersionId = 9;

    optional ELockMode LockMode = 10;
    optional uint64 TimeoutSeconds = 11;
}

message TEvWriteResult {
    enum EStatus {
        STATUS_UNSPECIFIED = 0;
        STATUS_PREPARED = 1;
        STATUS_COMPLETED = 2;
        STATUS_ABORTED = 3;
        STATUS_INTERNAL_ERROR = 4;
        STATUS_OVERLOADED = 5;
        STATUS_CANCELLED = 6;
        STATUS_BAD_REQUEST = 7;
        STATUS_SCHEME_CHANGED = 8;
        STATUS_LOCKS_BROKEN = 9;
        STATUS_DATABASE_DISK_SPACE_QUOTA_EXCEEDED = 10;
        STATUS_WRONG_SHARD_STATE = 11;
        STATUS_CONSTRAINT_VIOLATION = 12;
        STATUS_DISK_GROUP_OUT_OF_SPACE = 13;
    }

    // Status
    optional EStatus Status = 1;
    repeated Ydb.Issue.IssueMessage Issues = 2;

    // Transactions params
    optional uint64 Origin = 3;
    optional uint64 TxId = 4;
    optional uint64 MinStep = 5;
    optional uint64 MaxStep = 6;
    repeated fixed64 DomainCoordinators = 7;
    optional uint64 Step = 8;
    optional uint64 OrderId = 9;
    repeated TLock TxLocks = 10;
    optional TTabletInfo TabletInfo = 11;

    // Other params
    optional uint64 OverloadSubscribed = 12;

    // Statistics
    optional NKikimrQueryStats.TTxStats TxStats = 13;

    // Commit version when available
    optional NKikimrProto.TRowVersion CommitVersion = 14;
}

message TEvLockRows {
    // A per-sender request id, useful for cancellation. Shards identify
    // requests using (Sender, RequestId) pairs, which must be unique.
    optional uint64 RequestId = 1;

    // Lock parameters of the current query or transaction
    optional uint64 LockId = 2;
    optional uint32 LockNodeId = 3;
    optional uint64 LockTimestamp = 4;

    // A desired lock mode, only PESSIMISTIC lock modes are supported
    optional ELockMode LockMode = 5;

    // An optional snapshot of the current query
    // Rows which have been modified since the specified snapshot will be
    // returned in the ModifiedKeys list after locking, which usually means
    // a read committed transaction will need to re-read these rows.
    optional NKikimrProto.TRowVersion Snapshot = 6;

    // Previously acquired locks at the destination shard, which are validated
    // before processing the request. This could be used to avoid re-acquiring
    // the same LockId with a different counter (implied lock breaking), or
    // to support savepoints in the future. All locks listed here are implied
    // to belong to the same transaction and will never conflict with each
    // other.
    repeated TLock ExistingLocks = 7;

    // When true rows already locked by other transactions are skipped without
    // waiting for conflicting transactions to commit or abort.
    optional bool SkipLocked = 8;

    // Destination global table id, must include SchemaVersion to detect schema changes
    optional TTableId TableId = 9;

    // A list of primary key column ids used in the payload. This list is
    // matched against current table schema, and specifies column order, which
    // must currently match schema primary key exactly, including order.
    repeated uint32 ColumnIds = 10 [packed = true];

    // Index of the message payload which contains serialized keys to lock.
    optional uint64 PayloadIndex = 11;

    // Format of the payload. DataShard only supports FORMAT_CELLVEC at the
    // moment, where serialized data is in the TSerializedCellMatrix format,
    // with each row matching ColumnIds cells with primary keys to lock.
    optional EDataFormat PayloadFormat = 12;

    // An optional schema for the serialized keys, used for FORMAT_ARROW
    optional string PayloadSchema = 13;
}

message TEvLockRowsCancel {
    // A previously received request matching (Sender, RequestId) to cancel,
    // indicating Sender is no longer interested in the response. No response
    // will be sent when cancellation succeeds.
    optional uint64 RequestId = 1;
}

message TEvLockRowsResult {
    enum EStatus {
        STATUS_UNSPECIFIED = 0;
        STATUS_SUCCESS = 1;
        STATUS_BAD_REQUEST = 2;
        STATUS_OVERLOADED = 3;
        STATUS_WRONG_SHARD_STATE = 4;
        STATUS_LOCKS_BROKEN = 5;
        STATUS_SCHEME_ERROR = 6;
        STATUS_SCHEME_CHANGED = 7;
        STATUS_INTERNAL_ERROR = 8;
    }

    // TabletId of the replying shard
    optional uint64 TabletId = 1;

    // RequestId specified in TEvLockRows request
    optional uint64 RequestId = 2;

    // The response status and optional issues
    optional EStatus Status = 3;
    repeated Ydb.Issue.IssueMessage Issues = 4;

    // A list of acquired/updated locks
    // May include previously acquired locks which have been broken
    repeated TLock Locks = 5;

    // A list of row indexes from the request which have been successfully locked
    repeated uint32 LockedKeys = 6 [packed = true];

    // A list of row indexes from the request which have been skipped when SkipLocked is true
    repeated uint32 SkippedKeys = 7 [packed = true];

    // A list of row indexes from the request which have been modified since the specified Snapshot
    repeated uint32 ModifiedKeys = 8 [packed = true];
}
